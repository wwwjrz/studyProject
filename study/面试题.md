# CSS

## 平时布局都用什么

1. 浮动布局：float 属性（float:left/right;）
2. 定位布局：position 属性（position:static/fixed/absolute/relative;）
3. flex 布局：display:flex 属性
   (1). flex-direction：主轴的方向。
   (2). flex-wrap：超出父容器子容器的排列样式。
   (3). flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式。
   (4). justify-content：子容器在主轴的排列方向。
   (5). align-items：子容器在交叉轴的排列方向。
   (6). align-content：多根轴线的对齐方式。

## 如何实现三栏布局，中间自适应。

1. 左右两边容器相对父容器定位,左边 top:0; left:0; 右边 top:0;right:0;中间占满一行，但通过 margin 和左右两边留出位置

2. display:flex; 弹性布局,将父容器设置为 display:flex;。盒内元素两端对齐，将中间容器设置 flex:1，填充空白区域。 代码如下：

3. display: grid; 网格布局，将父容器设置成网格布局 grid-template-columns: 200px auto 200px; 设置三列网格其中左右分别 200px，中间自适应

## position 都有什么属性

1. absolute：绝对定位 ，绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于 <html>

2. fixed：固定定位 ，与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。

3. relative：相对定位 ，相对于其正常位置进行定位，不影响其他元素的偏移。

4. sticky：粘性定位 ，可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位

5. static：静态定位 ，HTML 元素默认情况下的定位方式为 static（静态），静态定位的元素不受 top、bottom、left 和 right 属性的影响，它始终根据页面的正常流进行定位

## display 有哪些值、哪些用法？

1. none：隐藏对象

2. inline：指定对象为内联元素

3. block：指定对象为块元素。

4. inline-block：对象为内联块元素

5. flex：将对象作为弹性伸缩盒显示

6. table：表格布局

# VUE

## vue 的通讯方式

1. props/$emit：父组件 A 通过 props 的方式向子组件 B 传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现

2. $emit/$on：通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件,实现了任何组件间的通信，包括父子、兄弟、跨级。

3. $attrs/$listeners：$attrs与$listeners 是两个对象，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners 里存放的是父组件中绑定的非原生事件。

4. $parent / $children与 ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，$parent / $children：访问父 / 子实例

5. vuex：是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态。

   1. 各个模块

   **state**：用于数据的存储，是 store 中的唯一数据源

   **getters**：如 vue 中的计算属性一样，基于 state 数据的二次包装，常用于数据的筛选和多个数据的相关性计算

   **mutations**：类似函数，改变 state 数据的唯一途径，且不能用于处理异步事件

   **actions**：类似于 mutation，用于提交 mutation 来改变状态，而不直接变更状态，可以包含任意异步操作

   **modules**：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护

# JS

## 数组方法

1. pop：删除数组的最后一项

2. push：向数组的末尾添加新元素

3. shift：删除数组的第一项

4. unshift：向数组首位添加新元素

5. splice：对数组进行增删改

6. join：转为字符串

7. sort：排序

8. reverse：反转

9. filter：过滤

10. map：返回一个新数组

11. includes：判断数组中是否包含一个指定的值

## JS 有哪几种数据类型

number，string，boolean，undefined，null，symbol：表示独一无二的值，bigint：表示任意大的整数

## 防抖和节流

1. 防抖：让某个触发事件在 n 秒内只会被执行一次（搜索框搜索输入。只需用户最后一次输入完，再发送请求）

```js
function debounce(fn, delay) {
  let timer = null
  clearTimeout(timer) // 下次调用时会清除上次的timer， 然后重新延迟
  timer = setTimeout(function () {
    fn()
  }, delay)
}
```

2. 节流：一个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。（手机号、邮箱验证输入检测）

```js
function throttle(fn, wait) {
  let timer = null
  return function () {
    let context = this
    let args = arguments
    if (!timer) {
      timer = setTimeout(() => {
        timer = null
        fn.apply(context, args)
      }, wait)
    }
  }
}
```

# 算法

## 数字每三位用逗号分割的算法

```js
// 不处理小数，默认保留三位小数
Number(num).toLocaleString()
// 通过传值可修改保留小数位数
// 最小
Number(num).toLocaleString(undefined, { minimumFractionDigits: 6 })
// 最小
Number(num).toLocaleString(undefined, { maximumFractionDigits: 2 })
```

```js
function transform(num) {
  let numStr = num.toString()
  let numTwo = numStr.split('.')
  let [start, end] = numTwo
  let startData = start.split('').reverse()
  let result = []

  for (let i = 0; i < startData.length; i++) {
    result.push(startData[i])
    if ((i + 1) % 3 == 0 && i != startData.length - 1) {
      result.push(',')
    }
  }
  if (end) {
    return result.reverse().join('') + ('.' + end)
  } else {
    return result.reverse().join('')
  }
}
let arsd = transform(123456789101.123456)
```

# 网络

## HTTP 协商缓存，强缓存。

1. HTTP 强缓存

Cache-Control：

1. rivate：仅浏览器可以缓存（默认值）；

2. public：浏览器和代理服务器都可以缓存；

3. max-age=xxx：过期时间单位秒；

4. no-cache：不进行强缓存；

5. no-store：不强缓存，也不协商缓存）
